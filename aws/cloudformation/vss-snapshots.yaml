AWSTemplateFormatVersion: '2010-09-09'
Description: VSS Snapshots (EBS instances with tag VSSSnapshot = true)

Parameters:
  ScheduleExpression:
    Type: String
    Default: "cron(0 3 * * ? *)"

Resources:

  VSSSnapshotsDoc:
    Type: "AWS::SSM::Document"
    Properties:
      DocumentType: Command
      Content: |
        {
          "schemaVersion": "2.2",
          "description": "Create a app consistent snapshot of all ebs volumes attached to an instance.",
          "parameters": {
            "ExcludeBootVolume": {
              "type": "String",
              "description": "(Optional) Exclude the boot volume.",
              "allowedValues": [
                "True",
                "False"
              ],
              "default": "False"
            },
            "RetentionDays": {
              "type": "String",
              "default": "7",
              "description": "(Optional) Specify number of retention days.",
              "maxChars": 3
            },
            "tags": {
              "type": "String",
              "default": "",
              "description": "(Optional) Specify tags to add to snaphots. Key=tag-key,Value=tag-value",
              "allowedPattern": "^([Kk]ey=(.*),[Vv]alue=(.*);?)*$"
            }
          },
          "mainSteps": [
            {
              "precondition": {
                "StringEquals": [
                  "platformType",
                  "Windows"
                ]
              },
              "action": "aws:runPowerShellScript",
              "name": "runPowerShellScript",
              "inputs": {
                "runCommand": [
        "# Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
        "",
        "#",
        "# Function to begin the VSS snapshot of a EBS volume",
        "#",
        "function EbsVssFreeze($driveLetter, $startTime = (Get-Date)) {",
        "",
        "    if ($script:inProgress -eq $true) {",
        "        return",
        "    }",
        "",
        "",
        "    $namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
        "    $pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe, ",
        "        [System.IO.Pipes.PipeDirection]::In,",
        "        1,",
        "        [System.IO.Pipes.PipeTransmissionMode]::Byte)",
        "",
        "    Write-Host 'Pipe server started after' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "",
        "    $script:inProgress = $true",
        "",
        "    $vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
        "    if (Test-Path \"$vssAgentPath\") {",
        "        $exeString = \"/c `\"$vssAgentPath`\" \" + $driveLetter",
        "        if ((get-process \"ec2-vss-agent\" -ea SilentlyContinue) -ne $Null) { ",
        "            Write-Host \"ec2-vss-agent is current running, snapshot already in progress.\" ",
        "            exit 1",
        "        }",
        "        $process = Start-Process $vssAgentPath $driveLetter -PassThru",
        "    } else {",
        "        Write-Host 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package arn:aws:ssm:::package/AwsVssComponents'",
        "        exit 1",
        "    }",
        "    Write-Host 'Waiting for Freeze pipe at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "",
        "    #",
        "    # Wait for connection from provider indicating VSS freeze has begun",
        "    #",
        "    $pipeServer.WaitForConnection()",
        "    Write-Host 'Freeze pipe connected at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "    try {",
        "        $pipeReader = new-object System.IO.StreamReader($pipeServer)",
        "        $string = $pipeReader.ReadLine()",
        "        Write-Host 'EBS snapshot Freeze message received at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms' $string",
        "",
        "    } catch {",
        "        Write-Host \"Freeze pipe read failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "        Write-Error  $_",
        "    } finally {",
        "        Write-Host 'Disposing of pipes at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "        $pipeReader.Dispose()",
        "        $pipeServer.Dispose()",
        "    }",
        "}",
        "",
        "",
        "#",
        "# Function to release VSS freeze of EBS volume after snapshot is complete.",
        "#",
        "function EbsVssThaw($startTime = (Get-Date)) {",
        "",
        "    # Return if a VSS snapshot is not in progress",
        "    if ($script:inProgress -eq $false) {",
        "        Write-Host 'script not in progress'",
        "        return $false;",
        "    }",
        "",
        "    $namedPipe = '8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72'",
        "    $pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\".\",",
        "        $namedPipe, ",
        "        [System.IO.Pipes.PipeDirection]::In,",
        "        [System.IO.Pipes.PipeOptions]::Asynchronous)",
        "",
        "    try {",
        "        Write-Host \"Thaw pipe waiting for connection at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "        # Wait for thaw connection from provider",
        "        $pipeClient.Connect(10000)",
        "        Write-Host \"Thaw pipe connected at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "        try {",
        "            $pipeReader = new-object System.IO.StreamReader($pipeClient)",
        "",
        "            $string = $pipeReader.ReadLine()",
        "        } catch {",
        "            Write-Host \"Thaw pipe read failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "            Write-Error  $_",
        "        ",
        "        } finally {",
        "            $pipeReader.Dispose()",
        "        }",
        "    } catch {",
        "        Write-Host \"Thaw pipe connection failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "        Write-Error  $_",
        "        ",
        "    } finally {",
        "        $pipeClient.Dispose()",
        "    }",
        "",
        "    Write-Host \"Pipe message read at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "",
        "    $script:inProgress = $false",
        "",
        "    if ($string -like 'EBS done') {",
        "        return $true",
        "    } else {",
        "        Write-Host \"Thaw pipe returned wrong value: \" $string ",
        "        return $false",
        "    }",
        "}",
        "",
        "",
        "#",
        "# Helper function to retrieve EC2 instance meta-data.",
        "#",
        "function Get-EC2InstanceMetadata {",
        "    param([string]$Path)",
        "    Invoke-RestMethod -Uri \"http://169.254.169.254/latest/$Path\"",
        "}",
        "",
        "",
        "#",
        "# Helper function to convert SCSI target ID to xvd* EBS device name.",
        "#",
        "function Convert-SCSITargetIdToDeviceName {",
        "    param([int]$SCSITargetId)",
        "    If ($SCSITargetId -eq 0) {",
        "        return '/dev/sda1'",
        "    }",
        "    $deviceName = 'xvd'",
        "    If ($SCSITargetId -gt 25) {",
        "        $deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
        "    }",
        "    $deviceName += [char](0x61 + $SCSITargetId % 26)",
        "    return $deviceName",
        "}",
        "",
        "",
        "#",
        "# Retrieve drive list with EBS volume ID for C5 and newer instance types",
        "#",
        "function DriveLetterToEbsVolumeId {",
        "    ",
        "    $disklist = @()",
        "",
        "    # Exit if we are not on at least Server 2012",
        "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
        "        return $null",
        "    }",
        "",
        "    $physicalDisks = Get-PhysicalDisk | Where-Object {$_.AdapterSerialNumber -like \"vol*\"}",
        "",
        "    if ($physicalDisks.Count -eq 0) {",
        "        return $null",
        "    }",
        "    ",
        "    foreach ($pd in $physicalDisks) {",
        "",
        "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
        "",
        "        if ($pool1 -eq $null) {",
        "            $sdv = $pd | Get-PhysicalDiskStorageNodeView -ErrorAction SilentlyContinue",
        "",
        "            $partition = $sdv | Get-Partition -ErrorAction SilentlyContinue",
        "",
        "            if ($partition -ne $null) {",
        "                $vol = Get-Volume -Partition $partition",
        "",
        "                $diskList += New-Object PSObject -Property @{",
        "                    Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
        "                    Partitions    = 0;",
        "                    DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
        "                    EbsVolumeId   = If ($pd -eq $null) { $null } Else { ($pd.AdapterSerialNumber).Replace(\"vol\", \"vol-\") };",
        "                    Device        = If ($pd -eq $null) { $null } Else { $pd.FriendlyName };",
        "                    VirtualDevice = If ($vol -eq $null) { $null } Else { $vol.UniqueId };",
        "                    VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
        "                }",
        "            }",
        "        } else {",
        "            foreach ($vol in Get-Volume) {",
        "                $pool2 = Get-StoragePool -Volume $vol",
        "                if ($pool1 -like $pool2) {",
        "                    $diskList += New-Object PSObject -Property @{",
        "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
        "                        Partitions    = 0;",
        "                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
        "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { ($pd.AdapterSerialNumber).Replace(\"vol\", \"vol-\") };",
        "                        Device        = If ($pd -eq $null) { $null } Else { $pd.FriendlyName };",
        "                        VirtualDevice = If ($vol -eq $null) { $null } Else { $vol.UniqueId };",
        "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
        "                    }",
        "                }",
        "            }",
        "        }",
        "    }",
        "",
        "    return $disklist",
        "}",
        "",
        "",
        "",
        "#",
        "# Helper function to collect connected EBS volumes attached to local EC2 instance.",
        "#",
        "function Get-EbsConnectedVolume {",
        "",
        "    $diskList = DriveLetterToEbsVolumeId",
        "    if ($diskList.Count -gt 0) {",
        "        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
        "        foreach ($disk in $diskList) {",
        "            $blockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $disk.EbsVolumeId }",
        "            $disk.Device = If ($BlockDevice -eq $null) { $null } Else { $blockDevice.DeviceName }",
        "        }",
        "        return $diskList",
        "    }",
        "",
        "    Try {",
        "        $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
        "        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
        "        $VirtualDeviceMap = @{}",
        "        (Get-EC2InstanceMetadata \"meta-data/block-device-mapping\").Split(\"`n\") | ForEach-Object {",
        "            $VirtualDevice = $_",
        "            $BlockDeviceName = Get-EC2InstanceMetadata \"meta-data/block-device-mapping/$VirtualDevice\"",
        "            $VirtualDeviceMap[$BlockDeviceName] = $VirtualDevice",
        "            $VirtualDeviceMap[$VirtualDevice] = $BlockDeviceName",
        "        }",
        "    } Catch {",
        "        Write-Host \"Could not access the AWS API, therefore, VolumeId is not available. ",
        "        Verify that your instance role has Describe-Instances permission.\" -ForegroundColor Yellow",
        "        throw",
        "    }",
        "",
        "    $diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
        "        $DiskDrive = $_",
        "        $Volumes = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | ForEach-Object {",
        "            $DiskPartition = $_",
        "            Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
        "        }",
        "        If ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
        "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
        "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -eq $BlockDeviceName }",
        "            $VirtualDevice = If ($VirtualDeviceMap.ContainsKey($BlockDeviceName)) { $VirtualDeviceMap[$BlockDeviceName] } Else { $null }",
        "        } ElseIf ($DiskDrive.PNPDeviceID -like \"*PROD_AMAZON_EC2_NVME*\") {",
        "            $BlockDeviceName = Get-EC2InstanceMetadata \"meta-data/block-device-mapping/ephemeral$($DiskDrive.SCSIPort - 2)\"",
        "            $BlockDevice = $null",
        "            $VirtualDevice = If ($VirtualDeviceMap.ContainsKey($BlockDeviceName)) { $VirtualDeviceMap[$BlockDeviceName] } Else { $null }",
        "        } Else {",
        "            $BlockDeviceName = $null",
        "            $BlockDevice = $null",
        "            $VirtualDevice = $null",
        "        }",
        "        New-Object PSObject -Property @{",
        "            Disk          = $DiskDrive.Index;",
        "            Partitions    = $DiskDrive.Partitions;",
        "            DriveLetter   = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
        "            EbsVolumeId   = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
        "            Device        = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
        "            VirtualDevice = If ($VirtualDevice -eq $null) { $null } Else { $VirtualDevice };",
        "            VolumeName    = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
        "        }",
        "    } | Sort-Object Disk",
        "",
        "    return $diskList",
        "}",
        "",
        "",
        "#",
        "# Tag Snapshots",
        "#",
        "function Tag-Snapshots {",
        "    param(",
        "        [System.Object[]]$SnapshotsData,",
        "        [boolean]$AppConsistent,",
        "        [int]$RetentionDays,",
        "        [Parameter(Mandatory = $false)][amazon.EC2.Model.Tag[]]$Tags",
        "    )",
        "    $Tag = new-object amazon.EC2.Model.Tag",
        "    $Tag.Key = \"AppConsistent\"",
        "    $Tag.Value = \"$AppConsistent\"",
        "    $Tags += $Tag",
        "    $DeleteOn = (Get-Date).AddDays($RetentionDays).ToString(\"yyyy-MM-dd\")",
        "    $Tag = new-object amazon.EC2.Model.Tag",
        "    $Tag.Key = \"DeleteOn\"",
        "    $Tag.Value = \"$DeleteOn\"",
        "    $Tags += $Tag",
        "    $Tag = new-object amazon.EC2.Model.Tag",
        "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
        "    $Tag.Key = \"Name\"",
        "    $Tag.Value = \"vss-snapshot-\" + $InstanceId",
        "    $Tags += $Tag",
        "    $Tag = new-object amazon.EC2.Model.Tag",
        "    $Tag.Key = \"InstanceId\"",
        "    $Tag.Value = \"$InstanceId\"",
        "    $Tags += $Tag",
        "    foreach ($SnapshotData in $SnapshotsData) {",
        "        $Tag = new-object amazon.EC2.Model.Tag",
        "        $Tag.Key = \"Device\"",
        "        $Tag.Value = $SnapshotData.Device",
        "        $AllTags = $Tags + $Tag",
        "        New-EC2Tag -Resources $SnapshotData.SnapshotId -Tags $AllTags",
        "    }",
        "}",
        "",
        "function VssSnapshot() {",
        "    param(",
        "        [boolean]$ExcludeBootVolume,",
        "        [int]$RetentionDays,",
        "        [string]$Tags",
        "    )",
        "    $startTime = Get-Date",
        "    $VolumesToFreeze = @()",
        "    $DrivesToFreeze = @()",
        "    if ((Get-EC2InstanceMetadata \"meta-data/instance-type\").StartsWith(\"c5\",\"CurrentCultureIgnoreCase\")) {",
        "        Write-Host \"C5 instances not currently supported\"",
        "        exit 1",
        "    }",
        "",
        "    $volumeList = Get-EbsConnectedVolume",
        "    foreach ($v in $volumeList) {",
        "        if ( ($v.DriveLetter -ne $null) -and ($v.EbsVolumeId -ne $null)) {",
        "            if (($ExcludeBootVolume -eq $false) -or ($v.Device -ne \"/dev/sda1\")) {",
        "                $VolumesToFreezeString += ($v.DriveLetter -join ' ') + \" \"",
        "                $DrivesToFreeze += $v.DriveLetter",
        "                $VolumesToFreeze += $v",
        "            }",
        "        }",
        "    }",
        "    if ($VolumesToFreeze.Count -eq 0) {",
        "        Write-Host \"No mounted EBS drives detected\"",
        "        exit 1",
        "    }",
        "    $DrivesToFreezeString = ($DrivesToFreeze | sort -Unique) -join ' '",
        "",
        "    Write-Host \"Beginning snapshot for drives\" $DrivesToFreezeString",
        "",
        "    EbsVssFreeze $DrivesToFreezeString $startTime",
        "",
        "    Write-Host 'Freeze complete at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "    $SnapshotData = @()",
        "    foreach ($v in $VolumesToFreeze) {",
        "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
        "    $DescriptionCustom = \"VssSnapshot for volume \" + $v.EbsVolumeId + \" from instance \" + $InstanceId",
        "        $Snapshot = New-EC2Snapshot -VolumeId $v.EbsVolumeId -Description $DescriptionCustom",
        "        $SnapshotData +=",
        "        New-Object PSObject -Property @{",
        "            EbsVolumeId = $v.EbsVolumeId",
        "            Device      = $v.Device",
        "            SnapshotId  = $Snapshot.SnapshotId",
        "        }   ",
        "        Write-Host \"Created\" $Snapshot.SnapshotId \"from\" $v.EbsVolumeId \" device: \" $v.Device",
        "    }",
        "",
        "    Write-Host 'Starting Thaw at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "    $AppConsistent = EbsVssThaw $startTime",
        "    if ($AppConsistent) {",
        "        Write-Host 'Thaw successful at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "    } else {",
        "        Write-Host 'Thaw unsuccesful, snapshots may not be app consistent, see event log for more details' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
        "    }",
        "",
        "    [amazon.EC2.Model.Tag[]]$TagArray = @()",
        "    $Tags -split \";\" | ForEach-Object {",
        "        if (-not [string]::IsNullOrEmpty($_)) {",
        "            $TagParts = ($_ -split \",\", 2)",
        "            if ($TagParts.Count -ne 2) {",
        "                Write-Host \"Error parsing tags, tags need to be in the format Name=tag-key,Values=tag-value\"",
        "                return $false",
        "            }",
        "            $TagName, $TagValue = $TagParts",
        "            $Tag = new-object amazon.EC2.Model.Tag",
        "            $Tag.Key = ($TagName -split \"=\", 2)[1].Trim()",
        "            $Tag.Value = ($TagValue -split \"=\", 2)[1].Trim()",
        "            $TagArray += $Tag",
        "        }",
        "    }",
        "",
        "",
        "    Tag-Snapshots $SnapshotData $AppConsistent $RetentionDays $TagArray",
        "    return $AppConsistent",
        "}",
        "",
        "if ($callLocal -ne $true) {",
        "    [boolean]$ExcludeBootVolume = [System.Convert]::ToBoolean(\"{{ExcludeBootVolume}}\")",
        "",
        "    $RetentionDays = @\"",
        "{{RetentionDays}}",
        "\"@",
        "",
        "    $tags = @\"",
        "{{tags}}",
        "\"@",
        "",
        "    $AppConsistent = VssSnapshot $ExcludeBootVolume $RetentionDays $tags",
        "    exit [int](-not $AppConsistent)",
        "}",
        "",
        "",
        "",
        "",
                  ""
                ],
                "workingDirectory": "",
                "timeoutSeconds": "400"
              }
            }
          ]
        }

  VSSSnapshotsAssociation:
    Type: "AWS::SSM::Association"
    Properties:
      AssociationName: "Name"
      DocumentVersion: "$LATEST"
      Parameters:
        ExcludeBootVolume:
          - "False"
        RetentionDays:
          - "7"
      Name: !Ref VSSSnapshotsDoc
      ScheduleExpression: !Ref ScheduleExpression
      Targets:
      - Key: "tag:VSSSnapshot"
        Values:
        - "true"

# ------

Outputs:

  VSSSnapshotsDoc:
    Value: !Ref VSSSnapshotsDoc
